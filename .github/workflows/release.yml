name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  actions: read

jobs:
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published || 'false' }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install semantic-release plugins
        run: |
          npm install --no-save \
            semantic-release \
            @semantic-release/github

      - name: Check if release needed
        id: check
        run: |
          if npx semantic-release --dry-run | grep -q "Published release"; then
            echo "release_needed=true" >> $GITHUB_OUTPUT
          else
            echo "release_needed=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Semantic Release
        id: semantic
        if: steps.check.outputs.release_needed == 'true'
        run: |
          npx semantic-release
          echo "new_release_published=true" >> $GITHUB_OUTPUT
          # Get the latest tag as version
          echo "new_release_version=$(git describe --tags --abbrev=0 | sed 's/^v//')" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build:
    name: Build ${{ matrix.goos }}-${{ matrix.goarch }}
    runs-on: ubuntu-latest
    needs: release
    if: needs.release.outputs.new_release_published == 'true'
    strategy:
      fail-fast: false
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]

    env:
      CGO_ENABLED: "0"
      VERSION: v${{ needs.release.outputs.new_release_version }}
      BIN: tkube

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Print Go env
        run: go env

      - name: Build
        run: |
          export GOOS=${{ matrix.goos }}
          export GOARCH=${{ matrix.goarch }}

          # Create directories
          mkdir -p dist pkg

          # Binary name
          OUT="${BIN}"
          if [ "$GOOS" = "windows" ]; then OUT="${BIN}.exe"; fi

          # Embed version into binary (strip 'v' prefix from tag)
          VERSION_CLEAN=${VERSION#v}
          LDFLAGS="-s -w -X main.version=${VERSION_CLEAN}"

          echo ">> Building ${OUT} for $GOOS/$GOARCH (version: ${VERSION_CLEAN})"
          go build -trimpath -ldflags "$LDFLAGS" -o "dist/${OUT}" ./cmd/tkube

          # Verify binary was created
          if [ ! -f "dist/${OUT}" ]; then
            echo "Error: Binary was not created"
            exit 1
          fi

          # Package
          PKG_NAME="${BIN}_${VERSION}_${GOOS}_${GOARCH}"
          mkdir -p "pkg/${PKG_NAME}"
          cp "dist/${OUT}" "pkg/${PKG_NAME}/"
          
          # Copy additional files if they exist
          [ -f LICENSE ] && cp LICENSE "pkg/${PKG_NAME}/"
          [ -f README.md ] && cp README.md "pkg/${PKG_NAME}/"

          # Create archive
          cd pkg
          if [ "$GOOS" = "windows" ]; then
            zip -r "${PKG_NAME}.zip" "${PKG_NAME}"
            echo "Created: ${PKG_NAME}.zip"
          else
            tar -czf "${PKG_NAME}.tar.gz" "${PKG_NAME}"
            echo "Created: ${PKG_NAME}.tar.gz"
          fi
          cd ..

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BIN }}_${{ env.VERSION }}_${{ matrix.goos }}_${{ matrix.goarch }}
          path: |
            pkg/*.tar.gz
            pkg/*.zip
          if-no-files-found: error

  checksums:
    name: Checksums
    needs: [release, build]
    if: needs.release.outputs.new_release_published == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Generate SHA256
        run: |
          cd dist
          # Find all archives and generate checksums
          find . -type f \( -name "*.tar.gz" -o -name "*.zip" \) -exec basename {} \; | sort | while read file; do
            find . -name "$file" -exec sha256sum {} \; | sed 's|./[^/]*/||'
          done > checksums.txt
          echo "Generated checksums:"
          cat checksums.txt

      - name: Upload checksums
        uses: actions/upload-artifact@v4
        with:
          name: checksums
          path: dist/checksums.txt

  publish:
    name: Publish Release Assets
    needs: [release, build, checksums]
    if: needs.release.outputs.new_release_published == 'true'
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.release.outputs.id }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: List files
        run: |
          echo "Artifacts:"
          find dist -type f -maxdepth 3 -print

      - name: Upload Release Assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.release.outputs.new_release_version }}
          files: |
            dist/**/*.tar.gz
            dist/**/*.zip
            dist/checksums/checksums.txt

  update-formula:
    name: Update Homebrew-tap Formula
    needs: [release, checksums, publish]
    runs-on: ubuntu-latest
    if: needs.release.outputs.new_release_published == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main
          fetch-depth: 0

      - name: Download checksums
        uses: actions/download-artifact@v4
        with:
          name: checksums
          path: checksums

      - name: Generate Homebrew Formula
        env:
          VERSION: v${{ needs.release.outputs.new_release_version }}
        run: |
          # Extract version without 'v' prefix
          VERSION_CLEAN=${VERSION#v}
          
          # Get SHA256 for macOS ARM64 binary (the recommended one for Homebrew)
          MACOS_ARM64_SHA=$(grep "_darwin_arm64.tar.gz" checksums/checksums.txt | awk '{print $1}')
          
          echo "ğŸ“‹ Creating Homebrew formula for version ${VERSION_CLEAN}"
          echo "ğŸ” SHA256: ${MACOS_ARM64_SHA}"
          
          # Create the formula
          cat > tkube.rb << EOF
          class Tkube < Formula
            desc "Enhanced Teleport kubectl wrapper with auto-authentication"
            homepage "https://github.com/${{ github.repository }}"
            url "https://github.com/${{ github.repository }}/releases/download/${VERSION}/tkube_${VERSION}_darwin_arm64.tar.gz"
            sha256 "${MACOS_ARM64_SHA}"
            license "MIT"
            version "${VERSION_CLEAN}"
          
            depends_on "kubernetes-cli"
          
            def install
              bin.install "tkube"
            end
          
            test do
              system "#{bin}/tkube", "version"
            end
          end
          EOF
          
          echo "âœ… Formula created successfully"

      - name: Update Homebrew Tap Repository
        env:
          VERSION: v${{ needs.release.outputs.new_release_version }}
          HOMEBREW_TAP_REPO: ${{ github.repository_owner }}/homebrew-tap
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸº Updating Homebrew tap repository..."
          
          # Check if homebrew-tap repository exists
          if ! curl -s -f -H "Authorization: token ${GITHUB_TOKEN}" \
             "https://api.github.com/repos/${HOMEBREW_TAP_REPO}" > /dev/null; then
            echo "âš ï¸  Homebrew tap repository not found: ${HOMEBREW_TAP_REPO}"
            echo ""
            echo "ğŸ’¡ To create a Homebrew tap:"
            echo "   1. Create repository: ${HOMEBREW_TAP_REPO}"
            echo "   2. Make it public"
            echo "   3. The workflow will automatically populate it"
            echo ""
            echo "ğŸ”§ Quick setup:"
            echo "   gh repo create ${HOMEBREW_TAP_REPO} --public"
            echo "   # Then re-run this workflow"
            exit 0
          fi
          
          echo "âœ… Homebrew tap repository found: ${HOMEBREW_TAP_REPO}"
          
          # Clone the tap repository
          echo "ğŸ“¥ Cloning tap repository..."
          git clone "https://x-access-token:${GITHUB_TOKEN}@github.com/${HOMEBREW_TAP_REPO}.git" homebrew-tap
          cd homebrew-tap
          
          # Configure git
          git config --global user.email "action@github.com"
          git config --global user.name "GitHub Action"
          
          # Create Formula directory if it doesn't exist
          mkdir -p Formula
          
          # Copy updated formula
          echo "ğŸ“‹ Copying updated formula to tap repository..."
          if [ ! -f "../tkube.rb" ]; then
            echo "âŒ Formula file not found: ../tkube.rb"
            ls -la ../ | head -10
            exit 1
          fi
          cp ../tkube.rb Formula/tkube.rb
          echo "âœ… Formula copied successfully"
          
          # Verify the formula has the correct version
          echo "ğŸ” Verifying formula update..."
          if ! grep -q "${VERSION}" Formula/tkube.rb; then
            echo "âŒ Formula doesn't contain version ${VERSION}"
            echo "Formula content:"
            cat Formula/tkube.rb | grep -A1 -B1 "url\|sha256"
            exit 1
          fi
          
          # Check if there are changes to commit
          if git diff --quiet Formula/tkube.rb 2>/dev/null; then
            echo "â„¹ï¸  No changes detected in tap repository"
            echo "   Formula is already up to date with ${VERSION}"
          else
            echo "ğŸ“ Changes detected, committing update..."
            
            # Show what changed
            echo "Changes being made:"
            git diff Formula/tkube.rb || true
            
            # Commit and push
            git add Formula/tkube.rb
            cat > commit_message.txt << EOF
            Update tkube to ${VERSION}
            
            Automated update from main repository release.
            
            Changes:
            - Updated source URL to ${VERSION}
            - Updated SHA256 checksum
            - Version: ${VERSION}
            
            This update was triggered by a new release in the main tkube repository.
            EOF
            git commit -F commit_message.txt
